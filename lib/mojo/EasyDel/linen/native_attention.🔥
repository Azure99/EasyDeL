from runtime.llcl import Runtime
from math import math
from algorithm.functional import vectorize


fn native_rms_norm[
    T: DType, nelts: Int
](
    inout output: DTypePointer[T],
    x: DTypePointer[T],
    w: DTypePointer[T],
    epsilon: SIMD[T, 1],
    size: Int,
    runtime: Runtime,
) -> None:
    var loop_val: SIMD[T, nelts] = SIMD[T, nelts](0.0)

    @parameter
    fn _sum_power_operation[_nelts: Int](i: Int):
        if _nelts < nelts:
            loop_val[0] += (x.offset(i).simd_load[_nelts](0) ** 2).reduce_add()
        else:
            loop_val += x.offset(i).simd_load[nelts](0) ** 2

    vectorize[nelts, _sum_power_operation](size)

    var normed: SIMD[T, 1] = loop_val.reduce_add()
    normed = normed / size + epsilon
    normed = 1.0 / math.sqrt(normed)

    @parameter
    fn _norm[_nelts: Int](idx: Int):
        let val = w.simd_load[_nelts](idx) * normed * x.simd_load[_nelts](idx)
        output.offset(idx).simd_store[_nelts](0, val)

    vectorize[nelts, _norm](size)


fn native_rope_rotation_multi_head[
    T: DType
](
    inout q: DTypePointer[T],
    inout k: DTypePointer[T],
    fcr_row: DTypePointer[T],
    fci_row: DTypePointer[T],
    num_attention_heads: Int,
    num_key_values_head: Int,
    head_dims: Int,
) -> None:
    let off_rot = head_dims // 2
    for i in range(num_attention_heads):
        for j in range(off_rot):
            let cu_fcr = fcr_row.offset(j).load(0)
            let cu_fci = fci_row.offset(j).load(0)
            let q0 = q.offset(i * head_dims + j).load(0)
            let q1 = q.offset(i * head_dims + j + off_rot).load(0)
            q.offset(i * head_dims + j).store(0, q0 * cu_fcr - q1 * cu_fci)
            q.offset(i * head_dims + j + off_rot).store(0, q0 * cu_fci + q1 * cu_fcr)
            if i < num_key_values_head:
                let k0 = k.offset(i * head_dims + j).load(0)
                let k1 = k.offset(i * head_dims + j + off_rot).load(0)
                k.offset(i * head_dims + j).store(0, k0 * cu_fcr - k1 * cu_fci)
                k.offset(i * head_dims + j + off_rot).store(
                    0, k0 * cu_fci + k1 * cu_fcr
                )


fn native_rope_rotation_multi_query[
    T: DType
](
    inout q: DTypePointer[T],
    inout k: DTypePointer[T],
    fcr_row: DTypePointer[T],
    fci_row: DTypePointer[T],
    num_attention_heads: Int,
    num_key_values_head: Int,
    head_dims: Int,
) -> None:
    let off_rot = 1
    for i in range(num_attention_heads):
        for j in range(0, head_dims, 2):
            let cu_fcr = fcr_row.offset(j // 2).load(0)
            let cu_fci = fci_row.offset(j // 2).load(0)
            let q0 = q.offset(i * head_dims + j).load(0)
            let q1 = q.offset(i * head_dims + j + off_rot).load(0)
            q.offset(i * head_dims + j).store(0, q0 * cu_fcr - q1 * cu_fci)
            q.offset(i * head_dims + j + off_rot).store(0, q0 * cu_fci + q1 * cu_fcr)
            if i < num_key_values_head:
                let k0 = k.offset(i * head_dims + j).load(0)
                let k1 = k.offset(i * head_dims + j + off_rot).load(0)
                k.offset(i * head_dims + j).store(0, k0 * cu_fcr - k1 * cu_fci)
                k.offset(i * head_dims + j + off_rot).store(
                    0, k0 * cu_fci + k1 * cu_fcr
                )


fn native_rope_rotation[
    T: DType
](
    inout q: DTypePointer[T],
    inout k: DTypePointer[T],
    fcr_row: DTypePointer[T],
    fci_row: DTypePointer[T],
    hidden_size: Int,
    num_key_values_head: Int,
    head_dims: Int,
) -> None:
    for i in range(0, head_dims * num_key_values_head, 2):
        let half_ = i % head_dims // 2
        let fcr = fcr_row.offset(half_).load(0)
        let fci = fci_row.offset(half_).load(0)
        let q0 = q.offset(i).load(0)
        let q1 = q.offset(i + 1).load(0)
        let k0 = k.offset(i).load(0)
        let k1 = k.offset(i + 1).load(0)
        q.offset(i).store(0, q0 * fcr - q1 * fci)
        q.offset(i + 1).store(0, q0 * fci + q1 * fcr)
        k.offset(i).store(0, k0 * fcr - k1 * fci)
        k.offset(i + 1).store(0, k0 * fci + k1 * fcr)

    for i in range(head_dims * num_key_values_head, hidden_size, 2):
        let half_ = i % head_dims // 2
        let fcr = fcr_row.offset(half_).load(0)
        let fci = fci_row.offset(half_).load(0)
        let q0 = q.offset(i).load(0)
        let q1 = q.offset(i + 1).load(0)
        q.offset(i).store(0, q0 * fcr - q1 * fci)
        q.offset(i + 1).store(0, q0 * fci + q1 * fcr)
