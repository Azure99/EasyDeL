from ..array import Array, matmul
from algorithm.functional import parallelize, vectorize
import math


fn linear[
    T: DType, nelts: Int, cores: Int
](inout o: Array[T], x: Array[T], w: Array[T]):
    matmul[T, nelts](o, x, w, cores)


fn linear[T: DType, cores: Int](x: Array[T], w: Array[T]) -> Array[T]:
    var o: Array[T] = Array[T](x, w)
    linear[T, o.nelts, cores](o, x, w)
    return o ^


fn embedding[
    T: DType, cores: Int
](input_ids: DynamicVector[Int], w: Array[T]) -> Array[T]:
    let hidden: Int = w.dim(-1)
    let size: Int = w.dim(-2)

    var embed: Array[T] = Array[T](len(input_ids), hidden)
    embed.alloc(0.0)

    @parameter
    fn _row(i: Int):
        let axis: Int = input_ids[i]

        @parameter
        fn _set_cols[nelts: Int](j: Int):
            embed.store[nelts](i, j, w.load[nelts](axis, j))

        vectorize[embed.nelts, _set_cols](hidden)

    parallelize[_row](len(input_ids), cores)
    return embed ^


fn embedding[
    T: DType, cores: Int, off: Int
](input_ids: InlinedFixedVector[off, Int], w: Array[T]) -> Array[T]:
    let hidden: Int = w.dim(-1)
    let size: Int = w.dim(-2)

    var embed: Array[T] = Array[T](len(input_ids), hidden)
    embed.alloc(0.0)

    @parameter
    fn _row(i: Int):
        let axis: Int = input_ids[i]

        @parameter
        fn _set_cols[nelts: Int](j: Int):
            embed.store[nelts](i, j, w.load[nelts](axis, j))

        vectorize[embed.nelts, _set_cols](hidden)

    parallelize[_row](len(input_ids), cores)
    return embed ^


fn embedding[
    T: DType, cores: Int
](input_ids: VariadicList[Int], w: Array[T]) -> Array[T]:
    let hidden: Int = w.dim(-1)
    let size: Int = w.dim(-2)

    var embed: Array[T] = Array[T](len(input_ids), hidden)
    embed.alloc(0.0)

    @parameter
    fn _row(i: Int):
        let axis: Int = input_ids[i]

        @parameter
        fn _set_cols[nelts: Int](j: Int):
            embed.store[nelts](i, j, w.load[nelts](axis, j))

        vectorize[embed.nelts, _set_cols](hidden)

    parallelize[_row](len(input_ids), cores)
    return embed ^


@always_inline
fn rms_layernorm[
    T: DType, nelts: Int, cores: Int
](x: Array[T], w: Array[T], epsilon: SIMD[T, 1]) -> Array[T]:
    var res: Array[T] = Array[T](x.array_shape)
    res.alloc(0.0)
    let num_elements: Int = x.dim(-1)

    @parameter
    fn _parallelizer(i: Int):
        var sp: SIMD[T, nelts] = SIMD[T, nelts](0.0)

        @parameter
        fn _do_sum_pow[_nelts: Int](j: Int):
            if _nelts < nelts:
                sp[0] += (x.load[_nelts](i, j) ** 2).reduce_add()
            else:
                sp += x.load[nelts](i, j) ** 2

        vectorize[nelts, _do_sum_pow](num_elements)
        var normed: SIMD[T, 1] = sp.reduce_add()
        normed = normed / num_elements + epsilon
        normed = 1.0 / math.sqrt(normed)

        @parameter
        fn _do_element_wise[_nelts: Int](j: Int):
            let val = w.load[_nelts](j) * normed * x.load[_nelts](i, j)
            res.store[_nelts](i, j, val)

        vectorize[nelts, _do_element_wise](num_elements)

    parallelize[_parallelizer](x.dim(-2), cores)
    return res ^
