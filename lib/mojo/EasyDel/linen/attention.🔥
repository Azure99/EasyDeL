from ..array import Array, ArrayShape
from algorithm.functional import vectorize
from math import math


fn rms_norm[
    T: DType
](inout C: Array[T], x: Array[T], w: Array[T], epsilon: SIMD[T, 1]) -> None:
    alias nelts: Int = Array[T].nelts
    var sp: SIMD[T, nelts] = SIMD[T, nelts](0.0)

    @parameter
    fn _do_sum_pow[_nelts: Int](size: Int):
        if _nelts < nelts:
            sp[0] += (x.load[_nelts](size) ** 2).reduce_add()
        else:
            sp += x.load[nelts](size) ** 2

    vectorize[nelts, _do_sum_pow](x.num_elements())
    var normed: SIMD[T, 1] = sp.reduce_add()
    normed /= x.num_elements()
    normed += epsilon
    normed = 1.0 / math.sqrt(normed)

    @parameter
    fn _do_element_wise[_nelts: Int](size: Int):
        C.store[_nelts](size, x.load[_nelts](size) * normed * w.load[_nelts](size))

    vectorize[nelts, _do_element_wise](x.num_elements())


fn rope_rotation_multi_query[
    T: DType
](
    inout q: Array[T],
    inout k: Array[T],
    fcr_row: DTypePointer[T],
    fci_row: DTypePointer[T],
    num_attention_heads: Int,
    num_key_value_heads: Int,
    head_dims: Int,
) -> None:
    let off_rot = 1
    for i in range(num_attention_heads):
        for j in range(0, head_dims, 2):
            let cu_fcr = fcr_row.offset(j // 2).load(0)
            let cu_fci = fci_row.offset(j // 2).load(0)
            let q0 = q.load[1](i * head_dims + j)
            let q1 = q.load[1](i * head_dims + j + off_rot)
            q.store[1](i * head_dims + j, q0 * cu_fcr - q1 * cu_fci)
            q.store[1](i * head_dims + j + off_rot, q0 * cu_fci + q1 * cu_fcr)
            if i < num_key_value_heads:
                let k0 = k.load[1](i * head_dims + j)
                let k1 = k.load[1](i * head_dims + j + off_rot)
                k.store[1](i * head_dims + j, k0 * cu_fcr - k1 * cu_fci)
                k.store[1](i * head_dims + j + off_rot, k0 * cu_fci + k1 * cu_fcr)
