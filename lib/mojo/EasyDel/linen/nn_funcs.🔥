from ..array import Array, matmul
from algorithm.functional import parallelize, vectorize
import math


fn linear[
    DT: DType, nelts: Int, cores: Int, parallelized: Bool
](inout o: Array[DT], x: Array[DT], w: Array[DT]):
    matmul[DT, nelts, cores, parallelized](o, x, w)


fn linear[DT: DType, cores: Int](x: Array[DT], w: Array[DT]) -> Array[DT]:
    var o: Array[DT] = Array[DT](x, w)
    linear[DT, o.nelts, cores, True](o, x, w)
    return o


fn embedding[
    DT: DType, nelts: Int, cores: Int
](input_ids: DynamicVector[Int], w: Array[DT]) -> Array[DT]:
    let last_dim: Int = w.dim(-1)
    let batch: Int = len(input_ids)

    var embed: Array[DT] = Array[DT](batch, last_dim)
    embed.alloc(0.0)

    @parameter
    fn _row(i: Int):
        let axis: Int = input_ids[i]

        @parameter
        fn _cols[_nelts: Int](j: Int):
            embed.store[_nelts](VariadicList[Int](i, j), w.load[_nelts](axis, j))

        vectorize[nelts, _cols](last_dim)

    parallelize[_row](batch, cores)
    return embed
    

fn embedding[
    DT: DType, nelts: Int, cores: Int
](input_ids: VariadicList[Int], w: Array[DT]) -> Array[DT]:
    let last_dim: Int = w.dim(-1)
    let batch: Int = len(input_ids)

    var embed: Array[DT] = Array[DT](batch, last_dim)
    embed.alloc(0.0)

    @parameter
    fn _row(i: Int):
        let axis: Int = input_ids[i]

        @parameter
        fn _cols[_nelts: Int](j: Int):
            embed.store[_nelts](VariadicList[Int](i, j), w.load[_nelts](axis, j))

        vectorize[nelts, _cols](last_dim)

    parallelize[_row](batch, cores)
    return embed


@always_inline
fn rms_layernorm[
    DT: DType, nelts: Int, cores: Int
](x: Array[DT], w: Array[DT], epsilon: SIMD[DT, 1]) -> Array[DT]:
    var res: Array[DT] = Array[DT](x.array_shape)
    res.alloc(0.0)
    let num_elements: Int = x.dim(-1)
    for b in range(x.num_elements() // (x.dim(-1) * x.dim(-2))):

        @parameter
        fn _parallelizer(i: Int):
            var sp: SIMD[DT, nelts] = SIMD[DT, nelts](0.0)

            @parameter
            fn _do_sum_pow[_nelts: Int](j: Int):
                if _nelts < nelts:
                    sp[0] += (x.load[_nelts](b, i, j) ** 2).reduce_add()
                else:
                    sp += x.load[nelts](b, i, j) ** 2

            vectorize[nelts, _do_sum_pow](num_elements)
            var normed: SIMD[DT, 1] = sp.reduce_add()
            normed = normed / num_elements + epsilon
            normed = 1.0 / math.sqrt(normed)

            @parameter
            fn _do_element_wise[_nelts: Int](j: Int):
                let val = w.load[_nelts](j) * normed * x.load[_nelts](b, i, j)
                res.store[_nelts](VariadicList[Int](b, i, j), val)

            vectorize[nelts, _do_element_wise](num_elements)

        parallelize[_parallelizer](x.dim(-2), cores)
    return res
