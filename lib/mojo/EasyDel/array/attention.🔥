# from .matrix_struct import Matrix
# from runtime.llcl import Runtime
# from math import math
# from algorithm.functional import vectorize


# fn rms_norm[
#     T: DType, nelts: Int
# ](
#     inout output: DTypePointer[T],
#     x: DTypePointer[T],
#     w: DTypePointer[T],
#     epsilon: SIMD[T, 1],
#     size: Int,
#     runtime: Runtime,
# ):
#     var loop_val: SIMD[T, nelts] = SIMD[T, nelts](0.0)

#     @parameter
#     fn _sum_power_operation[_nelts: Int](i: Int):
#         if _nelts < nelts:
#             loop_val[0] += (x.offset(i).simd_load[_nelts](0) ** 2).reduce_add()
#         else:
#             loop_val += x.offset(i).simd_load[nelts](0) ** 2

#     vectorize[nelts, _sum_power_operation](size)

#     var normed: SIMD[T, 1] = loop_val.reduce_add()
#     normed = normed / size + epsilon
#     normed = 1.0 / math.sqrt(normed)

#     @parameter
#     fn _norm[_nelts: Int](idx: Int):
#         let val = w.simd_load[_nelts](idx) * normed * x.simd_load[_nelts](idx)
#         output.offset(idx).simd_store[_nelts](0, val)

#     vectorize[nelts, _norm](size)


# fn rms_norm[
#     nelts: Int
# ](
#     inout output: DTypePointer[DType.float32],
#     x: DTypePointer[DType.float32],
#     w: DTypePointer[DType.float32],
#     epsilon: SIMD[DType.float32, 1],
#     size: Int,
#     runtime: Runtime,
# ):
#     var loop_val: SIMD[DType.float32, nelts] = SIMD[DType.float32, nelts](0.0)

#     @parameter
#     fn _sum_power_operation[_nelts: Int](i: Int):
#         if _nelts < nelts:
#             loop_val[0] += (x.offset(i).simd_load[_nelts](0) ** 2).reduce_add()
#         else:
#             loop_val += x.offset(i).simd_load[nelts](0) ** 2

#     vectorize[nelts, _sum_power_operation](size)

#     var normed: SIMD[DType.float32, 1] = loop_val.reduce_add()
#     normed = normed / size + epsilon
#     normed = 1.0 / math.sqrt(normed)

#     @parameter
#     fn _norm[_nelts: Int](idx: Int):
#         let val = w.simd_load[_nelts](idx) * normed * x.simd_load[_nelts](idx)
#         output.offset(idx).simd_store[_nelts](0, val)

#     vectorize[nelts, _norm](size)


# fn rms_norm[
#     nelts: Int
# ](
#     inout output: DTypePointer[DType.float16],
#     x: DTypePointer[DType.float16],
#     w: DTypePointer[DType.float16],
#     epsilon: SIMD[DType.float16, 1],
#     size: Int,
#     runtime: Runtime,
# ):
#     var loop_val: SIMD[DType.float16, nelts] = SIMD[DType.float16, nelts](0.0)

#     @parameter
#     fn _sum_power_operation[_nelts: Int](i: Int):
#         if _nelts < nelts:
#             loop_val[0] += (x.offset(i).simd_load[_nelts](0) ** 2).reduce_add()
#         else:
#             loop_val += x.offset(i).simd_load[nelts](0) ** 2

#     vectorize[nelts, _sum_power_operation](size)

#     var normed: SIMD[DType.float16, 1] = loop_val.reduce_add()
#     normed = normed / size + epsilon
#     normed = 1.0 / math.sqrt(normed)

#     @parameter
#     fn _norm[_nelts: Int](idx: Int):
#         let val = w.simd_load[_nelts](idx) * normed * x.simd_load[_nelts](idx)
#         output.offset(idx).simd_store[_nelts](0, val)

#     vectorize[nelts, _norm](size)


# fn rms_norm[
#     nelts: Int
# ](
#     inout output: DTypePointer[DType.bfloat16],
#     x: DTypePointer[DType.bfloat16],
#     w: DTypePointer[DType.bfloat16],
#     epsilon: SIMD[DType.bfloat16, 1],
#     size: Int,
#     runtime: Runtime,
# ):
#     var loop_val: SIMD[DType.bfloat16, nelts] = SIMD[DType.bfloat16, nelts](0.0)

#     @parameter
#     fn _sum_power_operation[_nelts: Int](i: Int):
#         if _nelts < nelts:
#             loop_val[0] += (x.offset(i).simd_load[_nelts](0) ** 2).reduce_add()
#         else:
#             loop_val += x.offset(i).simd_load[nelts](0) ** 2

#     vectorize[nelts, _sum_power_operation](size)

#     var normed: SIMD[DType.bfloat16, 1] = loop_val.reduce_add()
#     normed = normed / size + epsilon
#     normed = 1.0 / math.sqrt(normed)

#     @parameter
#     fn _norm[_nelts: Int](idx: Int):
#         let val = w.simd_load[_nelts](idx) * normed * x.simd_load[_nelts](idx)
#         output.offset(idx).simd_store[_nelts](0, val)

#     vectorize[nelts, _norm](size)


# # New Rope From Llama2.mojo https://github.com/tairov/llama2.mojo/blob/master/llama2.mojo


# fn rope_rotation_multi_head(
#     inout q: DTypePointer[DType.float32],
#     inout k: DTypePointer[DType.float32],
#     fcr_row: DTypePointer[DType.float32],
#     fci_row: DTypePointer[DType.float32],
#     num_attention_heads: Int,
#     num_key_values_head: Int,
#     head_dims: Int,
# ) -> None:
#     let off_rot = head_dims // 2
#     for i in range(num_attention_heads):
#         for j in range(off_rot):
#             let cu_fcr = fcr_row.offset(j).load(0)
#             let cu_fci = fci_row.offset(j).load(0)
#             let q0 = q.offset(i * head_dims + j).load(0)
#             let q1 = q.offset(i * head_dims + j + off_rot).load(0)
#             q.offset(i * head_dims + j).store(0, q0 * cu_fcr - q1 * cu_fci)
#             q.offset(i * head_dims + j + off_rot).store(0, q0 * cu_fci + q1 * cu_fcr)
#             if i < num_key_values_head:
#                 let k0 = k.offset(i * head_dims + j).load(0)
#                 let k1 = k.offset(i * head_dims + j + off_rot).load(0)
#                 k.offset(i * head_dims + j).store(0, k0 * cu_fcr - k1 * cu_fci)
#                 k.offset(i * head_dims + j + off_rot).store(
#                     0, k0 * cu_fci + k1 * cu_fcr
#                 )


# fn rope_rotation_multi_head(
#     inout q: DTypePointer[DType.float16],
#     inout k: DTypePointer[DType.float16],
#     fcr_row: DTypePointer[DType.float16],
#     fci_row: DTypePointer[DType.float16],
#     num_attention_heads: Int,
#     num_key_values_head: Int,
#     head_dims: Int,
# ) -> None:
#     let off_rot = head_dims // 2
#     for i in range(num_attention_heads):
#         for j in range(off_rot):
#             let cu_fcr = fcr_row.offset(j).load(0)
#             let cu_fci = fci_row.offset(j).load(0)
#             let q0 = q.offset(i * head_dims + j).load(0)
#             let q1 = q.offset(i * head_dims + j + off_rot).load(0)
#             q.offset(i * head_dims + j).store(0, q0 * cu_fcr - q1 * cu_fci)
#             q.offset(i * head_dims + j + off_rot).store(0, q0 * cu_fci + q1 * cu_fcr)
#             if i < num_key_values_head:
#                 let k0 = k.offset(i * head_dims + j).load(0)
#                 let k1 = k.offset(i * head_dims + j + off_rot).load(0)
#                 k.offset(i * head_dims + j).store(0, k0 * cu_fcr - k1 * cu_fci)
#                 k.offset(i * head_dims + j + off_rot).store(
#                     0, k0 * cu_fci + k1 * cu_fcr
#                 )


# fn rope_rotation_multi_head(
#     inout q: DTypePointer[DType.bfloat16],
#     inout k: DTypePointer[DType.bfloat16],
#     fcr_row: DTypePointer[DType.bfloat16],
#     fci_row: DTypePointer[DType.bfloat16],
#     num_attention_heads: Int,
#     num_key_values_head: Int,
#     head_dims: Int,
# ) -> None:
#     let off_rot = head_dims // 2
#     for i in range(num_attention_heads):
#         for j in range(head_dims // 2):
#             let cu_fcr = fcr_row.offset(j).load(0)
#             let cu_fci = fci_row.offset(j).load(0)
#             let q0 = q.offset(i * head_dims + j).load(0)
#             let q1 = q.offset(i * head_dims + j + off_rot).load(0)
#             q.offset(i * head_dims + j).store(0, q0 * cu_fcr - q1 * cu_fci)
#             q.offset(i * head_dims + j + off_rot).store(0, q0 * cu_fci + q1 * cu_fcr)
#             if i < num_key_values_head:
#                 let k0 = k.offset(i * head_dims + j).load(0)
#                 let k1 = k.offset(i * head_dims + j + off_rot).load(0)
#                 k.offset(i * head_dims + j).store(0, k0 * cu_fcr - k1 * cu_fci)
#                 k.offset(i * head_dims + j + off_rot).store(
#                     0, k0 * cu_fci + k1 * cu_fcr
#                 )


# fn rope_rotation_multi_query(
#     inout q: DTypePointer[DType.float32],
#     inout k: DTypePointer[DType.float32],
#     fcr_row: DTypePointer[DType.float32],
#     fci_row: DTypePointer[DType.float32],
#     num_attention_heads: Int,
#     num_key_values_head: Int,
#     head_dims: Int,
# ) -> None:
#     let off_rot = 1
#     for i in range(num_attention_heads):
#         for j in range(0, head_dims, 2):
#             let cu_fcr = fcr_row.offset(j // 2).load(0)
#             let cu_fci = fci_row.offset(j // 2).load(0)
#             let q0 = q.offset(i * head_dims + j).load(0)
#             let q1 = q.offset(i * head_dims + j + off_rot).load(0)
#             q.offset(i * head_dims + j).store(0, q0 * cu_fcr - q1 * cu_fci)
#             q.offset(i * head_dims + j + off_rot).store(0, q0 * cu_fci + q1 * cu_fcr)
#             if i < num_key_values_head:
#                 let k0 = k.offset(i * head_dims + j).load(0)
#                 let k1 = k.offset(i * head_dims + j + off_rot).load(0)
#                 k.offset(i * head_dims + j).store(0, k0 * cu_fcr - k1 * cu_fci)
#                 k.offset(i * head_dims + j + off_rot).store(
#                     0, k0 * cu_fci + k1 * cu_fcr
#                 )


# fn rope_rotation_multi_query(
#     inout q: DTypePointer[DType.float16],
#     inout k: DTypePointer[DType.float16],
#     fcr_row: DTypePointer[DType.float16],
#     fci_row: DTypePointer[DType.float16],
#     num_attention_heads: Int,
#     num_key_values_head: Int,
#     head_dims: Int,
# ) -> None:
#     let off_rot = 1
#     for i in range(num_attention_heads):
#         for j in range(0, head_dims, 2):
#             let cu_fcr = fcr_row.offset(j // 2).load(0)
#             let cu_fci = fci_row.offset(j // 2).load(0)
#             let q0 = q.offset(i * head_dims + j).load(0)
#             let q1 = q.offset(i * head_dims + j + off_rot).load(0)
#             q.offset(i * head_dims + j).store(0, q0 * cu_fcr - q1 * cu_fci)
#             q.offset(i * head_dims + j + off_rot).store(0, q0 * cu_fci + q1 * cu_fcr)
#             if i < num_key_values_head:
#                 let k0 = k.offset(i * head_dims + j).load(0)
#                 let k1 = k.offset(i * head_dims + j + off_rot).load(0)
#                 k.offset(i * head_dims + j).store(0, k0 * cu_fcr - k1 * cu_fci)
#                 k.offset(i * head_dims + j + off_rot).store(
#                     0, k0 * cu_fci + k1 * cu_fcr
#                 )


# fn rope_rotation_multi_query(
#     inout q: DTypePointer[DType.bfloat16],
#     inout k: DTypePointer[DType.bfloat16],
#     fcr_row: DTypePointer[DType.bfloat16],
#     fci_row: DTypePointer[DType.bfloat16],
#     num_attention_heads: Int,
#     num_key_values_head: Int,
#     head_dims: Int,
# ) -> None:
#     let off_rot = 1
#     for i in range(num_attention_heads):
#         for j in range(0, head_dims, 2):
#             let cu_fcr = fcr_row.offset(j // 2).load(0)
#             let cu_fci = fci_row.offset(j // 2).load(0)
#             let q0 = q.offset(i * head_dims + j).load(0)
#             let q1 = q.offset(i * head_dims + j + off_rot).load(0)
#             q.offset(i * head_dims + j).store(0, q0 * cu_fcr - q1 * cu_fci)
#             q.offset(i * head_dims + j + off_rot).store(0, q0 * cu_fci + q1 * cu_fcr)
#             if i < num_key_values_head:
#                 let k0 = k.offset(i * head_dims + j).load(0)
#                 let k1 = k.offset(i * head_dims + j + off_rot).load(0)
#                 k.offset(i * head_dims + j).store(0, k0 * cu_fcr - k1 * cu_fci)
#                 k.offset(i * head_dims + j + off_rot).store(
#                     0, k0 * cu_fci + k1 * cu_fcr
#                 )


# fn rope_rotation(
#     inout q: DTypePointer[DType.float32],
#     inout k: DTypePointer[DType.float32],
#     fcr_row: DTypePointer[DType.float32],
#     fci_row: DTypePointer[DType.float32],
#     hidden_size: Int,
#     num_key_values_head: Int,
#     head_dims: Int,
# ) -> None:
#     for i in range(0, head_dims * num_key_values_head, 2):
#         let half_ = i % head_dims // 2
#         let fcr = fcr_row.offset(half_).load(0)
#         let fci = fci_row.offset(half_).load(0)
#         let q0 = q.offset(i).load(0)
#         let q1 = q.offset(i + 1).load(0)
#         let k0 = k.offset(i).load(0)
#         let k1 = k.offset(i + 1).load(0)
#         q.offset(i).store(0, q0 * fcr - q1 * fci)
#         q.offset(i + 1).store(0, q0 * fci + q1 * fcr)
#         k.offset(i).store(0, k0 * fcr - k1 * fci)
#         k.offset(i + 1).store(0, k0 * fci + k1 * fcr)

#     for i in range(head_dims * num_key_values_head, hidden_size, 2):
#         let half_ = i % head_dims // 2
#         let fcr = fcr_row.offset(half_).load(0)
#         let fci = fci_row.offset(half_).load(0)
#         let q0 = q.offset(i).load(0)
#         let q1 = q.offset(i + 1).load(0)
#         q.offset(i).store(0, q0 * fcr - q1 * fci)
#         q.offset(i + 1).store(0, q0 * fci + q1 * fcr)


# fn rope_rotation(
#     inout q: DTypePointer[DType.float16],
#     inout k: DTypePointer[DType.float16],
#     fcr_row: DTypePointer[DType.float16],
#     fci_row: DTypePointer[DType.float16],
#     hidden_size: Int,
#     num_key_values_head: Int,
#     head_dims: Int,
# ) -> None:
#     for i in range(0, head_dims * num_key_values_head, 2):
#         let half_ = i % head_dims // 2
#         let fcr = fcr_row.offset(half_).load(0)
#         let fci = fci_row.offset(half_).load(0)
#         let q0 = q.offset(i).load(0)
#         let q1 = q.offset(i + 1).load(0)
#         let k0 = k.offset(i).load(0)
#         let k1 = k.offset(i + 1).load(0)
#         q.offset(i).store(0, q0 * fcr - q1 * fci)
#         q.offset(i + 1).store(0, q0 * fci + q1 * fcr)
#         k.offset(i).store(0, k0 * fcr - k1 * fci)
#         k.offset(i + 1).store(0, k0 * fci + k1 * fcr)

#     for i in range(head_dims * num_key_values_head, hidden_size, 2):
#         let half_ = i % head_dims // 2
#         let fcr = fcr_row.offset(half_).load(0)
#         let fci = fci_row.offset(half_).load(0)
#         let q0 = q.offset(i).load(0)
#         let q1 = q.offset(i + 1).load(0)
#         q.offset(i).store(0, q0 * fcr - q1 * fci)
#         q.offset(i + 1).store(0, q0 * fci + q1 * fcr)


# fn rope_rotation(
#     inout q: DTypePointer[DType.bfloat16],
#     inout k: DTypePointer[DType.bfloat16],
#     fcr_row: DTypePointer[DType.bfloat16],
#     fci_row: DTypePointer[DType.bfloat16],
#     hidden_size: Int,
#     num_key_values_head: Int,
#     head_dims: Int,
# ) -> None:
#     for i in range(0, head_dims * num_key_values_head, 2):
#         let half_ = i % head_dims // 2
#         let fcr = fcr_row.offset(half_).load(0)
#         let fci = fci_row.offset(half_).load(0)
#         let q0 = q.offset(i).load(0)
#         let q1 = q.offset(i + 1).load(0)
#         let k0 = k.offset(i).load(0)
#         let k1 = k.offset(i + 1).load(0)
#         q.offset(i).store(0, q0 * fcr - q1 * fci)
#         q.offset(i + 1).store(0, q0 * fci + q1 * fcr)
#         k.offset(i).store(0, k0 * fcr - k1 * fci)
#         k.offset(i + 1).store(0, k0 * fci + k1 * fcr)

#     for i in range(head_dims * num_key_values_head, hidden_size, 2):
#         let half_ = i % head_dims // 2
#         let fcr = fcr_row.offset(half_).load(0)
#         let fci = fci_row.offset(half_).load(0)
#         let q0 = q.offset(i).load(0)
#         let q1 = q.offset(i + 1).load(0)
#         q.offset(i).store(0, q0 * fcr - q1 * fci)
#         q.offset(i + 1).store(0, q0 * fci + q1 * fcr)
