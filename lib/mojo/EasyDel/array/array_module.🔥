from utils.vector import InlinedFixedVector
from random import rand
from sys.info import simdwidthof
from math.math import (
    sqrt,
    sin,
    cos,
    tanh,
    tan,
    log,
    log2,
    atan,
    exp,
    exp2,
    min,
    pow,
    log10,
    log1p,
    logb,
    asin,
    acos,
    asinh,
    acosh,
    min,
    max,
)
import math
from algorithm.functional import (
    vectorize,
    vectorize_unroll,
    Static2DTileUnitFunc,
    parallelize,
)
from runtime.llcl import num_cores
from memory.memory import memset_zero

from .array_forward import (
    matmul,
    matmul_2d,
    matmul_EA,
    matmul_single_row,
    base_case_matmul,
    kernel_add,
    kernel_div,
    kernel_matmul,
    kernel_mul,
    kernel_pow,
    kernel_sub,
    array_abs,
    array_acos,
    array_add,
    array_asin,
    array_atan,
    array_copy,
    array_tanh,
    array_tan,
    array_cos,
    array_cosh,
    array_div,
    array_exp,
    array_exp2,
    array_relu,
    array_log,
    array_log2,
    array_mul,
    array_pow_all,
    array_sin,
    array_sinh,
    array_sqrt,
    array_pow,
    array_sub,
    relu,
    leaky_relu,
    softmax,
    silu,
    sigmoid,
    mean,
    ce,
    mse,
    sample,
    T_AXIS_0_2_1,
    T_AXIS_1_0_2,
    T_AXIS_2_1_0,
    CAT_3D_AXIS_2,
    rotate_half,
    convert_numpy_to_easydel_array,
)

alias dims_average_size = 5
alias debuging = True


# parts of this code is inspiered from https://github.com/andresnowak/Micro-Mojograd
@always_inline
fn matmul_shape[T: DType](A: Array[T], B: Array[T]) -> ArrayShape:
    if A.rank() == Int(2) and B.rank() == 1:
        return ArrayShape(A.dim(0))
    else:
        var res_dims = InlinedFixedVector[dims_average_size, Int](A.rank())
        for i in range(A.rank() - 1):
            res_dims.append(A.dim(i))
        res_dims.append(B.dim(-1))

        return ArrayShape(res_dims)


fn do_check(res: Bool, string: StringRef):
    if not res:
        # print(string)
        ...


struct ArrayShape:
    var _shape: Pointer[Int]
    var _strides: Pointer[Int]
    var _length: Int
    var _size: Int
    var _allocated: Bool

    fn __init__(inout self, shape: VariadicList[Int]) -> None:
        self._length = len(shape)
        self._shape = Pointer[Int]().alloc(self._length)
        self._strides = Pointer[Int]().alloc(self._length)
        memset_zero(self._strides, self._length)
        for i in range(self._length):
            self._shape.store(i, shape[i])
        self._size = 1
        self._allocated = True
        self._size = self.product_dims()

        self._strides.store(self._length - 1, 1)
        for i in range(self._length - 1):
            self._strides.store(
                self._length - i - 2,
                self._strides.load(self._length - i - 1)
                * self._shape[self._length - i - 1],
            )

    fn __init__(inout self, shape: DynamicVector[Int]) -> None:
        self._length = len(shape)
        self._shape = Pointer[Int]().alloc(self._length)
        self._strides = Pointer[Int]().alloc(self._length)
        memset_zero(self._strides, self._length)
        for i in range(self._length):
            self._shape.store(i, shape[i])
        self._size = 1
        self._allocated = True
        self._size = self.product_dims()
        self._strides.store(self._length - 1, 1)
        for i in range(self._length - 1):
            self._strides.store(
                self._length - i - 2,
                self._strides.load(self._length - i - 1)
                * self._shape[self._length - i - 1],
            )

    fn __init__[off: Int](inout self, shape: InlinedFixedVector[off, Int]) -> None:
        self._length = len(shape)
        self._shape = Pointer[Int]().alloc(self._length)
        self._strides = Pointer[Int]().alloc(self._length)
        memset_zero(self._strides, self._length)
        for i in range(self._length):
            self._shape.store(i, shape[i])
        self._size = 1
        self._allocated = True
        self._size = self.product_dims()

        self._strides.store(self._length - 1, 1)
        for i in range(self._length - 1):
            self._strides.store(
                self._length - i - 2,
                self._strides.load(self._length - i - 1)
                * self._shape[self._length - i - 1],
            )

    fn __init__(inout self, *elms: Int) -> None:
        let shape: VariadicList[Int] = VariadicList[Int](elms)
        self._length = len(shape)
        self._shape = Pointer[Int]().alloc(self._length)
        self._strides = Pointer[Int]().alloc(self._length)
        memset_zero(self._strides, self._length)
        for i in range(self._length):
            self._shape.store(i, shape[i])
        self._size = 1
        self._allocated = True
        self._size = self.product_dims()
        self._strides.store(self._length - 1, 1)
        for i in range(self._length - 1):
            self._strides.store(
                self._length - i - 2,
                self._strides.load(self._length - i - 1)
                * self._shape[self._length - i - 1],
            )

    fn __copyinit__(inout self: Self, ext: Self):
        self._size = ext._size
        self._shape = ext._shape
        self._length = ext._length
        self._allocated = ext._allocated
        self._strides = ext._strides

    fn __moveinit__(inout self: Self, owned ext: Self):
        self._shape = ext._shape ^
        self._strides = ext._strides ^
        self._length = ext._length
        self._size = ext._size
        self._allocated = ext._allocated

    fn __len__(self) -> Int:
        return self._size

    fn __eq__(self, other: ArrayShape) -> Bool:
        let mr = self.rank()
        for i in range(mr):
            if self._shape[i] != self._shape[i]:
                return False

        if mr != other.rank():
            return False
        return True

    fn __is__(self, other: ArrayShape) -> Bool:
        let mr = self.rank()
        for i in range(mr):
            if self._shape[i] != self._shape[i]:
                return False

        if mr != other.rank():
            return False
        return True

    fn __eq_matmul__(self, other: ArrayShape) -> Bool:
        let mr = self.rank()
        let tr = other.rank()
        if mr != tr:
            return False
        if mr == 1:
            return self == other
        for i in range(mr - 2):
            if self.dim(i) != other.dim(i):
                return False
        if self.dim(mr - 2) != other.dim(mr - 1):
            return False
        if self._allocated == False or other._allocated == False:
            return False
        return True

    fn __getitem__(self, idx: Int) -> Int:
        return self._shape[self.__ntp__(idx, self._length)]

    @staticmethod
    fn __ntp__(i: Int, m: Int) -> Int:
        if i < 0:
            return i + m
        return i

    fn rank(self: Self) -> Int:
        return self._length

    fn product_dims(self) -> Int:
        var res = 1
        for i in range(self.rank()):
            res *= self._shape[i]
        return res

    fn num_elements(self: Self) -> Int:
        return self._size

    fn dim(self, index: Int) -> Int:
        return self._shape[self.__ntp__(index, self._length)]

    fn shape(self: Self) -> Pointer[Int]:
        return self._shape

    fn strides(self: Self) -> Pointer[Int]:
        return self._strides

    @always_inline
    fn get_1d_pos[off: Int](self, index: InlinedFixedVector[off, Int]) -> Int:
        var product: Int = 1
        var position: Int = 0
        for i in range(self.rank() - 1, 0, -1):
            product *= self._shape[i]
            position += self.__ntp__(index[i - 1], self._shape[i - 1]) * product

        position += self.__ntp__(index[self.rank() - 1], self._shape[self.rank() - 1])
        return position

    @always_inline
    fn get_1d_pos[off: Int](self, index: StaticIntTuple[off]) -> Int:
        var product: Int = 1
        var position: Int = 0
        for i in range(self.rank() - 1, 0, -1):
            product *= self._shape[i]
            position += self.__ntp__(index[i - 1], self._shape[i - 1]) * product

        position += self.__ntp__(index[self.rank() - 1], self._shape[self.rank() - 1])
        return position

    fn shape_str(self: Self):
        print_no_newline("[")
        for i in range(self.rank()):
            if i == self.rank() - 1:
                print_no_newline(self[i])
            else:
                print_no_newline(self[i], ",")
        print("]")

    fn strides_str(self: Self):
        print_no_newline("[")
        for i in range(self.rank()):
            if i == self.rank() - 1:
                print_no_newline(self._strides[i])
            else:
                print_no_newline(self._strides[i], ",")
        print("]")


struct Array[T: DType]:
    var data: DTypePointer[T]
    var array_shape: ArrayShape
    var allocated: Int
    var shape: Pointer[Int]
    var strides: Pointer[Int]
    var extra_parameters: Pointer[Int]
    alias nelts: Int = simdwidthof[T]() * 2
    alias ArrayPointer: AnyType = DTypePointer[T]

    fn __init__(inout self: Self, array_shape: ArrayShape) -> None:
        r"""Init Array From ArrayShape(Alloc Zero)."""
        self.array_shape = array_shape
        self.data = self.ArrayPointer.alloc(0)
        self.allocated = 0
        self.shape = self.array_shape.shape()
        self.strides = self.array_shape.strides()
        self.extra_parameters = Pointer[Int].alloc(64)
        memset_zero(self.extra_parameters, 64)

    fn __init__(inout self: Self, A: Self, B: Self) -> None:
        r"""Init Array From Two other Arrays A and B For Matmul(Alloc One)."""
        self.__init__(matmul_shape[T](A, B))
        self.alloc(0.0)

    fn __init__(inout self: Self, *dim: Int):
        r"""Init Array from Int Args(Alloc Zero)."""
        self.array_shape = ArrayShape(VariadicList(dim))
        self.data = self.ArrayPointer.alloc(0)
        self.shape = self.array_shape.shape()
        self.strides = self.array_shape.strides()
        self.allocated = 0
        self.extra_parameters = Pointer[Int].alloc(64)
        memset_zero(self.extra_parameters, 64)

    fn __init__(inout self: Self, vl: VariadicList[Int]) -> None:
        r"""Init Array from VariadicList[Int](Alloc Zero)."""
        self.array_shape = ArrayShape(vl)
        self.data = self.ArrayPointer.alloc(0)
        self.shape = self.array_shape.shape()
        self.strides = self.array_shape.strides()
        self.allocated = 0
        self.extra_parameters = Pointer[Int].alloc(64)
        memset_zero(self.extra_parameters, 64)

    fn __init__(
        inout self: Self, value: DynamicVector[FloatLiteral], shape: ArrayShape
    ) -> None:
        r"""Init Array from ArrayShape and load data from DynamicVector[FloatLiteral](Alloc One).
        """
        self.array_shape = shape
        do_check(len(value) == self.array_shape.num_elements(), "Data Size miss match")
        self.data = self.ArrayPointer.alloc(self.array_shape.num_elements())
        self.allocated = 1
        self.shape = self.array_shape.shape()
        self.strides = self.array_shape.strides()
        for i in range(self.array_shape.num_elements()):
            self.data.simd_store[1](i, value[i])
        self.extra_parameters = Pointer[Int].alloc(64)
        memset_zero(self.extra_parameters, 64)

    fn __init__(
        inout self: Self, value: VariadicList[FloatLiteral], shape: ArrayShape
    ) -> None:
        r"""Init Array from ArrayShape and load data from VariadicList[FloatLiteral](Alloc One).
        """
        self.array_shape = shape
        do_check(len(value) == self.array_shape.num_elements(), "Data Size miss match")
        self.allocated = 1
        self.data = self.ArrayPointer.alloc(self.array_shape.num_elements())
        self.shape = self.array_shape.shape()
        self.strides = self.array_shape.strides()
        self.extra_parameters = Pointer[Int].alloc(64)
        memset_zero(self.extra_parameters, 64)
        for i in range(self.array_shape.num_elements()):
            self.data.simd_store[1](i, value[i])

    fn __init__(inout self: Self, pointer: DTypePointer[T], *dim: Int) -> None:
        self.data = pointer
        self.array_shape = ArrayShape(dim)
        self.allocated = 0
        self.shape = self.array_shape.shape()
        self.strides = self.array_shape.strides()
        self.extra_parameters = Pointer[Int].alloc(64)
        memset_zero(self.extra_parameters, 64)

    fn __moveinit__(inout self, owned ext: Self):
        self.data = ext.data
        self.array_shape = ext.array_shape
        self.allocated = ext.allocated
        self.shape = ext.array_shape.shape()
        self.strides = ext.array_shape.strides()
        self.extra_parameters = ext.extra_parameters

    fn __copyinit__(inout self, ext: Self):
        self.allocated = ext.allocated
        self.shape = ext.array_shape.shape()
        self.strides = ext.array_shape.strides()
        self.extra_parameters = ext.extra_parameters

        if self.allocated == 1:
            self.data = self.ArrayPointer.alloc(ext.array_shape.num_elements())
            self.array_shape = ext.array_shape

            @parameter
            fn _do[_nelts: Int](f: Int):
                let dt = ext.data.simd_load[_nelts](0)
                self.data.simd_store[_nelts](0, dt)

            vectorize[Self.nelts, _do](ext.array_shape.num_elements())
        else:
            self.data = self.ArrayPointer.alloc(0)
            self.array_shape = ext.array_shape

    fn __del__(owned self):
        if self.allocated == 1:
            self.data.free()

    fn init_from_buffer(inout self: Self, buffer: DTypePointer[T], *dim: Int) -> None:
        self.array_shape = ArrayShape(VariadicList(dim))
        self.shape = self.array_shape.shape()
        self.strides = self.array_shape.strides()
        self.data = buffer
        self.allocated = 0

    @always_inline
    fn set_data_from_buffer(inout self: Self, buffer: DTypePointer[T]) -> None:
        self.data = buffer

    @always_inline
    fn alloc(inout self: Self) -> None:
        r"""Allocate or Init The Array."""
        self.data = self.ArrayPointer.alloc(self.array_shape.num_elements())
        self.allocated = 1

    @always_inline
    fn alloc(inout self: Self, fill: SIMD[T, 1]) -> None:
        r"""Allocate or Init The Array and fill that with given fill number."""
        self.data = self.ArrayPointer.alloc(self.array_shape.num_elements())
        self.allocated = 1
        self.fill(fill)

    @always_inline
    fn random(inout self: Self) -> None:
        r"""Randomize The Data if the Array is Allocated."""
        if self.allocated == 1:
            rand[T](self.data, self.array_shape.num_elements())

    @always_inline
    fn zero(inout self):
        self.fill(0.0)

    @always_inline
    fn ones(inout self):
        self.fill(1.0)

    fn dtype(self) -> DType:
        return T

    @always_inline
    fn dim(self: Self, i: Int) -> Int:
        return self.array_shape.dim(i)

    @always_inline
    fn rank(self: Self) -> Int:
        return self.array_shape.rank()

    @always_inline
    fn num_elements(self: Self) -> Int:
        return self.array_shape.num_elements()

    @always_inline
    fn get_dynamic_axis(self: Self, *dims: Int) -> Int:
        let variadic: VariadicList[Int] = VariadicList[Int](dims)
        let slice_dv: DynamicVector[Int] = DynamicVector[Int]()
        if len(variadic) > self.rank():
            print(
                "DynamicAxis Errors -> Index out Of the Range (len(variadic) >"
                " self.rank())"
            )
        var pad: Int = 0
        for i in range(len(variadic)):
            var product: Int = 1
            for f in range(i + 1, self.rank()):
                product *= self.array_shape._shape[f]
            pad += variadic[i] * product
        if pad > self.num_elements():
            print(
                " DynamicAxis Errors -> Index out Of the Range (pad >"
                " self.num_elements)"
            )
        return pad

    # @always_inline
    # fn transpose[workers: Int = 2](self: Self, *dims: Int) -> Array[T]:
    #     # var res_shape: DynamicVector[Int] = DynamicVector[Int]()
    #     let dim = VariadicList[Int](dims)
    #     if len(dim) != self.rank():
    #         print("The Passed input dims to swap are not accept able for function")
    #         return Array[T]()
    #     if len(dim) != 3:
    #         print("Only 3D,2D arrays are accepted for transpose right now")
    #         return Array[T]()
    #     if dim[0] == 0 and dim[1] == 2 and dim[2] == 1:
    #         return T_AXIS_0_2_1[T, Array[T].nelts](self, workers)
    #     if dim[0] == 1 and dim[1] == 0 and dim[2] == 2:
    #         return T_AXIS_1_0_2[T, Array[T].nelts](self, workers)
    #     if dim[0] != 2 and dim[1] != 1 and dim[2] != 0:
    #         print("Open A Bug Form")
    #         return Array[T]()
    #     return T_AXIS_2_1_0[T, Array[T].nelts](self, workers)

    @always_inline
    fn T_[nelts: Int = Self.nelts, cores: Int = 2](self: Self) -> Array[T]:
        """
        Transpose the two last dims.
        """
        var dynamic_vector: DynamicVector[Int] = DynamicVector[Int]()
        for i in range(0, self.rank() - 2):
            if i >= 0 and self.rank() > 2:
                dynamic_vector.push_back(self.dim(i))

        dynamic_vector.push_back(self.dim(-1))
        dynamic_vector.push_back(self.dim(-2))
        var B: Array[T] = Array[T](dynamic_vector)
        B.alloc(0.00)
        let M = self.dim(-2)
        let N = self.dim(-1)

        for s in range(B.num_elements() // (M * N)):
            let offset = s * M * N
            for i in range(M):

                @parameter
                fn v_transpose[nelts: Int](j: Int):
                    B.data.simd_store[nelts](
                        offset + j * M + i,
                        self.data.simd_load[nelts](offset + i * N + j),
                    )

                vectorize[nelts, v_transpose](N)
        return B

    @always_inline
    fn reshape(inout self, *dims: Int) raises:
        let current_nelm = self.num_elements()
        let vs: VariadicList[Int] = VariadicList[Int](dims)
        var dynamic_index: Bool = False
        for i in range(len(vs)):
            if vs[i] == -1:
                dynamic_index = True
        if dynamic_index:
            var vvs: DynamicVector[Int] = DynamicVector[Int]()
            var num_elms: Int = 1
            for i in range(len(vs)):
                if vs[i] != -1:
                    num_elms *= vs[i]

            for i in range(len(vs)):
                if vs[i] == -1:
                    vvs.push_back(current_nelm // num_elms)
                else:
                    vvs.push_back(vs[i])
            let array_shape = ArrayShape(vvs)
            if array_shape.num_elements() != current_nelm:
                raise Error(
                    "Given new shape and number of elements in array won't Match"
                )
            self.array_shape = array_shape
        else:
            var num_elms: Int = 1
            for i in range(len(vs)):
                num_elms *= vs[i]
            if num_elms != current_nelm:
                raise Error(
                    "Given new shape and number of elements in array won't Match"
                )
            self.array_shape = ArrayShape(vs)

    @always_inline
    fn view(inout self, *dims: Int):
        r"""
        View Change Shape totaly and don't care if the new shape fits or doesn't.
        """
        let current_nelm = self.num_elements()
        let vs: VariadicList[Int] = VariadicList[Int](dims)
        var dynamic_index: Bool = False
        for i in range(len(vs)):
            if vs[i] == -1:
                dynamic_index = True
        if dynamic_index:
            var vvs: DynamicVector[Int] = DynamicVector[Int]()
            var num_elms: Int = 1
            for i in range(len(vs)):
                if vs[i] != -1:
                    num_elms *= vs[i]

            for i in range(len(vs)):
                if vs[i] == -1:
                    vvs.push_back(current_nelm // num_elms)
                else:
                    vvs.push_back(vs[i])
            let array_shape = ArrayShape(vvs)

            self.array_shape = array_shape
        else:
            var num_elms: Int = 1
            for i in range(len(vs)):
                num_elms *= vs[i]
            self.array_shape = ArrayShape(vs)

    @always_inline
    fn load[
        nelts: Int, off: Int
    ](self, index: InlinedFixedVector[off, Int]) -> SIMD[T, nelts]:
        let position = self.array_shape.get_1d_pos(index)
        self.assertation(position, self.array_shape._size)
        return self.data.simd_load[nelts](position)

    @always_inline
    fn load[nelts: Int, off: Int](self, index: StaticIntTuple[off]) -> SIMD[T, nelts]:
        let position = self.array_shape.get_1d_pos(index)
        self.assertation(position, self.array_shape._size)
        return self.data.simd_load[nelts](position)

    @always_inline
    fn load[nelts: Int](self, index: Int) -> SIMD[T, nelts]:
        let position = self.array_shape.__ntp__(index, self.array_shape._size)
        self.assertation(position, self.array_shape._size)
        return self.data.simd_load[nelts](position)

    @always_inline
    fn store[
        nelts: Int
    ](self, d1: Int, d2: Int, d3: Int, d4: Int, val: SIMD[T, nelts]) -> None:
        debug_assert(self.rank() != 4, "Miss match os requested shape (4D Store)")
        let index = (d1 * self.dim(-3) * self.dim(-2) * self.dim(-1)) + (
            d2 * self.dim(-2) * self.dim(-1)
        ) + (d3 * self.dim(-1)) + d4
        debug_assert(index > self.num_elements(), "Out OF range in Store 4D")
        self.data.simd_store[nelts](index, val)

    @always_inline
    fn store[nelts: Int](self, d1: Int, d2: Int, d3: Int, val: SIMD[T, nelts]) -> None:
        debug_assert(self.rank() != 3, "Miss match os requested shape (3D Store)")
        let index = d1 * self.dim(-2) * self.dim(-1) + d2 * self.dim(-1) + d3
        debug_assert(index > self.num_elements(), "Out OF range in Store 3D")
        self.data.simd_store[nelts](index, val)

    @always_inline
    fn store[nelts: Int](self, d1: Int, d2: Int, val: SIMD[T, nelts]) -> None:
        debug_assert(self.rank() != 2, "Miss match os requested shape (2D Store)")
        let index = d1 * self.dim(-1) + d2
        debug_assert(index > self.num_elements(), "Out OF range in Store 2D")
        self.data.simd_store[nelts](index, val)

    @always_inline
    fn load[nelts: Int](self, d1: Int, d2: Int, d3: Int, d4: Int) -> SIMD[T, nelts]:
        debug_assert(self.rank() != 3, "Miss match os requested shape (4D Load)")
        let index = (d1 * self.dim(-3) * self.dim(-2) * self.dim(-1)) + (
            d2 * self.dim(-2) * self.dim(-1)
        ) + (d3 * self.dim(-1)) + d4
        debug_assert(index > self.num_elements(), "Out OF range in Load 4D")
        return self.data.simd_load[nelts](index)

    @always_inline
    fn load[nelts: Int](self, d1: Int, d2: Int, d3: Int) -> SIMD[T, nelts]:
        debug_assert(self.rank() != 3, "Miss match os requested shape (3D Load)")
        let index = d1 * self.dim(-2) * self.dim(-1) + d2 * self.dim(-1) + d3
        debug_assert(index > self.num_elements(), "Out OF range in Load 3D")
        return self.data.simd_load[nelts](index)

    @always_inline
    fn load[nelts: Int](self, d1: Int, d2: Int) -> SIMD[T, nelts]:
        debug_assert(self.rank() != 2, "Miss match os requested shape (2D Load)")
        let index = d1 * self.dim(-1) + d2
        debug_assert(index > self.num_elements(), "Out OF range in Load 2D")
        return self.data.simd_load[nelts](index)

    @always_inline
    fn store[
        nelts: Int, off: Int
    ](self, index: InlinedFixedVector[off, Int], val: SIMD[T, nelts]) -> None:
        let position = self.array_shape.get_1d_pos(index)
        self.assertation(position, self.array_shape._size)
        self.data.simd_store[nelts](position, val)

    @always_inline
    fn store[
        nelts: Int, off: Int
    ](self, index: StaticIntTuple[off], val: SIMD[T, nelts]) -> None:
        let position = self.array_shape.get_1d_pos(index)
        self.assertation(position, self.array_shape._size)
        self.data.simd_store[nelts](position, val)

    @always_inline
    fn store[nelts: Int](self, index: Int, val: SIMD[T, nelts]) -> None:
        """Access the data as a 1D array."""
        let position = self.array_shape.__ntp__(index, self.array_shape._size)
        self.assertation(position, self.array_shape._size)
        self.data.simd_store[nelts](position, val)

    fn assertation(self: Self, i: Int, j: Int) -> None:
        do_check(True if i > j else False, "Index out of range")

    @always_inline
    fn __setitem__(self, index: Int, val: SIMD[T, 1]) -> None:
        return self.store[1](index, val)

    @always_inline
    fn __setitem__[
        off: Int
    ](self, index: InlinedFixedVector[off, Int], val: SIMD[T, 1]):
        return self.store[1](index, val)

    @always_inline
    fn __setitem__[off: Int](self, index: StaticIntTuple[off], val: SIMD[T, 1]):
        return self.store[1](index, val)

    @always_inline
    fn __setitem__(self, d1: Int, d2: Int, d3: Int, d4: Int, val: SIMD[T, 1]) -> None:
        return self.store[1](d1, d2, d3, d4, val)

    @always_inline
    fn __setitem__(self, d1: Int, d2: Int, d3: Int, val: SIMD[T, 1]) -> None:
        return self.store[1](d1, d2, d3, val)

    @always_inline
    fn __setitem__(self, d1: Int, d2: Int, val: SIMD[T, 1]) -> None:
        return self.store[1](d1, d2, val)

    @always_inline
    fn __getitem__[off: Int](self, index: InlinedFixedVector[off, Int]) -> SIMD[T, 1]:
        return self.load[1, off](index)

    @always_inline
    fn __getitem__[off: Int](self, index: StaticIntTuple[off]) -> SIMD[T, 1]:
        return self.load[1, off](index)

    @always_inline
    fn __getitem__(self, d1: Int, d2: Int, d3: Int, d4: Int) -> SIMD[T, 1]:
        return self.load[1](d1, d2, d3, d4)

    @always_inline
    fn __getitem__(self, d1: Int, d2: Int, d3: Int) -> SIMD[T, 1]:
        return self.load[1](d1, d2, d3)

    @always_inline
    fn __getitem__(self, d1: Int, d2: Int) -> SIMD[T, 1]:
        return self.load[1](d1, d2)

    @always_inline
    fn __getitem__(self, index: Int) -> SIMD[T, 1]:
        return self.load[1](index)

    @always_inline
    fn __element_wise_tensor_operation__[
        nelts: Int,
        outer_loop_func: fn[func: fn (Int) capturing -> None] (Int) capturing -> None,
        op_func: fn[T: DType, simd_width: Int] (
            x: SIMD[T, simd_width], y: SIMD[T, simd_width]
        ) -> SIMD[T, simd_width],
    ](self, other: Self) -> Self:
        do_check(
            self.array_shape == other.array_shape,
            "dimension aren't equal, can't do operation element wise.",
        )

        var res = Self(self.array_shape)
        res.alloc()
        let size = self.array_shape.num_elements()

        let last_dim = self.array_shape[-1]
        var dims_rest = size // last_dim

        @parameter
        fn _ol(i: Int):
            @parameter
            fn _iv[nelts: Int](j: Int):
                let index = i * last_dim + j

                res.store[nelts](
                    index,
                    op_func[T, nelts](
                        self.load[nelts](index), other.load[nelts](index)
                    ),
                )

            vectorize[nelts, _iv](last_dim)

        outer_loop_func[_ol](dims_rest)

        return res ^

    fn __element_wise_tensor_operation__[
        nelts: Int,
        outer_loop_func: fn[func: fn (Int) capturing -> None] (Int) capturing -> None,
        op_func: fn[T: DType, simd_width: Int] (x: SIMD[T, simd_width]) -> SIMD[
            T, simd_width
        ],
    ](self) -> Self:
        let res = Self(self.array_shape)
        let size = self.array_shape.num_elements()
        res.alloc()
        let last_dim = self.array_shape[-1]
        var dims_rest = size // last_dim

        @parameter
        fn _ol(i: Int):
            @parameter
            fn _iv[nelts: Int](j: Int):
                let index = i * last_dim + j

                res.store[nelts](
                    index,
                    op_func[T, nelts](self.load[nelts](index)),
                )

            vectorize[nelts, _iv](last_dim)

        outer_loop_func[_ol](dims_rest)

        return res ^

    fn __apply_math__[
        func: fn[type: DType, simd_width: Int] (arg: SIMD[type, simd_width]) -> SIMD[
            type, simd_width
        ],
    ](self: Self) -> Self:
        var res: Self = Self(self.array_shape)
        res.alloc()

        @parameter
        fn _do(size: Int):
            let ra = self.data.offset(size).simd_load[1](0)
            let rs: SIMD[T, 1] = func[T, 1](ra)
            res.data.offset(size).simd_store[1](0, rs)

        parallelize[_do](self.array_shape.num_elements())
        return res ^

    fn __apply_math__[
        nelts: Int,
        func: fn[TP: DType, simd_width: Int] (arg: SIMD[TP, simd_width]) -> SIMD[
            TP, simd_width
        ],
    ](self: Self) -> Self:
        var res: Self = self

        @parameter
        fn _do[_nelts: Int](size: Int):
            let rs: SIMD[T, _nelts] = func[T, _nelts](
                self.data.offset(size).simd_load[_nelts](0)
            )
            res.data.offset(size).simd_store[_nelts](0, rs)

        vectorize[nelts, _do](self.array_shape.num_elements())
        return res ^

    fn __apply_math__[
        func: fn[TP: DType, simd_width: Int] (arg: SIMD[TP, simd_width]) -> SIMD[
            TP, simd_width
        ],
    ](self: Self, num_cores: Int) -> Self:
        var res: Self = self

        @parameter
        fn _do(size: Int):
            let rs: SIMD[T, 1] = func[T, 1](
                self.data.offset(size).simd_load[1](0)
            ).reduce_add()
            res.data.offset(size).simd_store[1](0, rs)

        parallelize[_do](self.array_shape.num_elements(), num_cores)
        return res ^

    @always_inline
    fn __len__(inout self) -> Int:
        return self.num_elements()

    @always_inline
    fn mod[nelts: Int](self: Self, other: Self) -> Self:
        @parameter
        fn outer_loop[func: fn (Int) capturing -> None](size: Int):
            for i in range(size):
                func(i)

        return self.__element_wise_tensor_operation__[nelts, outer_loop, math.mod](
            other
        )

    fn mod[nelts: Int](self: Self, other: Self, num_cores: Int) -> Self:
        @parameter
        fn outer_loop[func: fn (Int) capturing -> None](size: Int) -> None:
            parallelize[func](size, num_cores)

        return self.__element_wise_tensor_operation__[nelts, outer_loop, math.mod](
            other
        )

    fn eq[nelts: Int](self, other: Self) -> Bool:
        do_check(
            self.array_shape == other.array_shape,
            "dimension aren't equal can't performe eq operation.",
        )

        var flag = True
        let size = self.array_shape.num_elements()

        @parameter
        fn iterate_vectorize[nelts: Int](i: Int):
            if self.load[nelts](i) != other.load[nelts](i):
                flag = False

        vectorize[nelts, iterate_vectorize](size)

        return flag

    fn eq[nelts: Int](self, other: Self, num_cores: Int, n_cores: Int) -> Bool:
        do_check(
            self.array_shape == other.array_shape,
            "dimension aren't equal can't performe eq operation.",
        )

        var flag = True
        let size = self.array_shape.num_elements()

        let first_dim = self.array_shape[0]
        let dims_rest = size // first_dim  # the rest of the dimensions

        @parameter
        fn iterate_parallel(i: Int):
            @parameter
            fn iterate_vectorize[nelts: Int](j: Int):
                let index = i * dims_rest + j

                if self.load[nelts](index) != other.load[nelts](index):
                    flag = False

            vectorize[nelts, iterate_vectorize](dims_rest)

        parallelize[iterate_parallel](first_dim, n_cores)

        return flag

    @staticmethod
    fn tile[
        tiled_fn: Static2DTileUnitFunc, tile_x: Int, tile_y: Int
    ](end_x: Int, end_y: Int):
        for y in range(0, end_y, tile_y):
            for x in range(0, end_x, tile_x):
                tiled_fn[tile_x, tile_y](x, y)

    @always_inline
    fn argmax(self: Self, axis: Int = -1) -> Int:
        var max_index: Int = 0
        var max_value: SIMD[T, 1] = self[0]
        for i in range(self.dim(axis)):
            if self[i] > max_value:
                max_index = i
                max_value = self[i]
        return max_index

    @always_inline
    fn fill(inout self: Self, val: SIMD[T, 1]) -> None:
        @parameter
        fn set_[nelts: Int](i: Int):
            self.data.simd_store[nelts](i, val)

        vectorize[Array[T].nelts, set_](self.num_elements())

    fn print_shape(self) -> None:
        self.array_shape.shape_str()

    fn print_strides(self) -> None:
        self.array_shape.strides_str()

    fn print_array(self) -> None:
        let size = self.array_shape.num_elements()

        var product = InlinedFixedVector[dims_average_size, Int](
            self.array_shape.rank() + 1
        )
        product.append(1)
        for index in range(self.array_shape.rank()):
            product.append(
                product[index] * self.array_shape[self.array_shape.rank() - 1 - index]
            )

        var count = 0
        for i in range(size + 1):
            let r_dt = self[i]
            count = 0
            for j in range(self.array_shape.rank()):
                if i % product[j + 1] == 0 and i != 0:
                    print_no_newline("]")
                    count += 1

            if i > 0 and i < size:
                print_no_newline(",")

            if i < size:
                for i in range(count):
                    print()
                    for i in range(self.array_shape.rank() - 1):
                        print_no_newline(" ")

            for j in range(self.array_shape.rank()):
                if i % product[j + 1] == 0 and i != size:
                    print_no_newline("[")

            if i < size:
                print_no_newline(r_dt)

        print()

    @always_inline
    fn matmul[nelts: Int = Self.nelts, cores: Int = 2](self, other: Self) -> Self:
        return matmul[T, nelts, cores](self, other)

    @always_inline
    fn cosh[nelts: Int = Array[T].nelts, cores: Int = 2](self) -> Array[T]:
        return array_cosh[T, nelts](self)

    @always_inline
    fn cos[nelts: Int = Array[T].nelts, cores: Int = 2](self) -> Array[T]:
        return array_cos[T, nelts](self)

    @always_inline
    fn tan[nelts: Int = Array[T].nelts, cores: Int = 2](self) -> Array[T]:
        return array_tan[T, nelts](self)

    @always_inline
    fn tanh[nelts: Int = Array[T].nelts, cores: Int = 2](self) -> Array[T]:
        return array_tanh[T, nelts](self)

    @always_inline
    fn atan[nelts: Int = Array[T].nelts, cores: Int = 2](self) -> Array[T]:
        return array_atan[T, nelts](self)

    @always_inline
    fn asin[nelts: Int = Array[T].nelts, cores: Int = 2](self) -> Array[T]:
        return array_asin[T, nelts](self)

    @always_inline
    fn acos[nelts: Int = Array[T].nelts, cores: Int = 2](self) -> Array[T]:
        return array_acos[T, nelts](self)

    @always_inline
    fn add[nelts: Int = Array[T].nelts, cores: Int = 2](self, other: Self) -> Array[T]:
        return array_add[T, nelts, cores](self, other)

    @always_inline
    fn abs[nelts: Int = Array[T].nelts, cores: Int = 2](self) -> Array[T]:
        return array_abs[T, nelts](self)

    @always_inline
    fn sqrt[nelts: Int = Array[T].nelts, cores: Int = 2](self) -> Array[T]:
        return array_sqrt[T, nelts](self)

    @always_inline
    fn sinh[nelts: Int = Array[T].nelts, cores: Int = 2](self) -> Array[T]:
        return array_sinh[T, nelts](self)

    @always_inline
    fn sin[nelts: Int = Array[T].nelts, cores: Int = 2](self) -> Array[T]:
        return array_sin[T, nelts](self)

    @always_inline
    fn pow_all[nelts: Int = Array[T].nelts, cores: Int = 2](self) -> Array[T]:
        return array_pow_all[T, nelts](self)

    @always_inline
    fn log[nelts: Int = Array[T].nelts, cores: Int = 2](self) -> Array[T]:
        return array_log[T, nelts](self)

    @always_inline
    fn log2[nelts: Int = Array[T].nelts, cores: Int = 2](self) -> Array[T]:
        return array_log2[T, nelts](self)

    @always_inline
    fn exp[nelts: Int = Array[T].nelts, cores: Int = 2](self) -> Array[T]:
        return array_exp[T, nelts](self)

    @always_inline
    fn exp2[nelts: Int = Array[T].nelts, cores: Int = 2](self) -> Array[T]:
        return array_exp2[T, nelts](self)

    @always_inline
    fn div[nelts: Int = Array[T].nelts, cores: Int = 2](self, other: Self) -> Array[T]:
        return array_div[T, nelts, cores](self, other)

    @always_inline
    fn mul[nelts: Int = Array[T].nelts, cores: Int = 2](self, other: Self) -> Array[T]:
        return array_mul[T, nelts, cores](self, other)

    @always_inline
    fn sub[nelts: Int = Array[T].nelts, cores: Int = 2](self, other: Self) -> Array[T]:
        return array_sub[T, nelts, cores](self, other)

    @always_inline
    fn pow[nelts: Int = Array[T].nelts, cores: Int = 2](self, other: Self) -> Array[T]:
        return array_pow[T, nelts, cores](self, other)

    @always_inline
    fn __add__(self: Self, other: Self) -> Self:
        return self.add[Self.nelts](other)

    @always_inline
    fn __mul__(self: Self, other: Self) -> Self:
        return self.mul[Self.nelts](other)

    @always_inline
    fn __matmul__(self: Self, other: Self) -> Self:
        return self.matmul[Self.nelts](other)

    @always_inline
    fn __sub__(self: Self, other: Self) -> Self:
        return self.sub[Self.nelts](other)

    @always_inline
    fn __truediv__(self: Self, other: Self) -> Self:
        return self.div[Self.nelts](other)

    @always_inline
    fn __mod__(self: Self, other: Self) -> Self:
        return self.mod[Self.nelts](other)

    @always_inline
    fn __len__(self: Self) -> Int:
        return self.array_shape.num_elements()

    @always_inline
    fn __eq__(self, other: Self) -> Bool:
        return self.eq[Self.nelts](other)

    @always_inline
    fn __ne__(self, other: Self) -> Bool:
        return not self.eq[Self.nelts](other)

    @always_inline
    fn __pow__(self: Self, other: Self) -> Self:
        return self.pow[Self.nelts](other)

    @always_inline
    fn __iadd__(inout self: Self, other: Self) -> None:
        self = self.add[Self.nelts](other)

    @always_inline
    fn __isub__(inout self: Self, other: Self) -> None:
        self = self.sub[Self.nelts](other)

    @always_inline
    fn __ipow__(inout self: Self, other: Self) -> None:
        self = self.pow[Self.nelts](other)

    @always_inline
    fn __imod__(inout self: Self, other: Self) -> None:
        self = self.mod[Self.nelts](other)

    @always_inline
    fn __idiv__(inout self: Self, other: Self) -> None:
        self = self.div[Self.nelts](other)

    @always_inline
    fn __itruediv__(inout self: Self, other: Self) -> None:
        self = self.div[Self.nelts](other)
