from memory.memory import memset_zero


struct Matrix[T: DType]:
    var data: DTypePointer[T]
    var rows: Int
    var cols: Int
    var layers: Int
    var allocated: Int

    fn __init__(inout self, cols: Int, rows: Int):
        self.data = DTypePointer[T].alloc(0)
        self.rows = rows
        self.cols = cols
        self.layers = 1
        self.allocated = 0

    fn __init__(inout self, cols: Int):
        self.data = DTypePointer[T].alloc(0)
        self.rows = 1
        self.layers = 1
        self.cols = cols
        self.allocated = 0

    fn __init__(inout self, layers: Int, cols: Int, rows: Int):
        self.__init__(cols, rows)
        self.layers = layers

    fn __del__(owned self):
        if self.allocated == 1:
            self.data.free()

    @always_inline
    fn alloc(inout self, fill: Int = 0):
        self.data = DTypePointer[T].alloc(self.size())
        self.allocated = 1
        if fill == 1:
            self.zero()

    @always_inline
    fn alloc_zero(inout self):
        self.alloc(1)

    @always_inline
    fn zero(inout self):
        memset_zero(self.data, self.size())

    @always_inline
    fn set_data_from_buffer(inout self, ptr: DTypePointer[T]) -> None:
        self.data = ptr
        return None

    fn set_data_from_buffer(inout self, ptr: DTypePointer[T], rows: Int) -> None:
        self.data = ptr
        self.rows = rows
        return None

    # set buf ptr with redefined rows, cols
    fn set_data_from_buffer(
        inout self, ptr: DTypePointer[T], cols: Int, rows: Int
    ) -> None:
        self.data = ptr
        self.rows = rows
        self.cols = cols
        return None

    fn set_data_from_buffer(
        inout self, ptr: DTypePointer[T], layers: Int, cols: Int, rows: Int
    ) -> None:
        self.data = ptr
        self.rows = rows
        self.cols = cols
        self.layers = layers
        return None

    @always_inline
    fn size(inout self) -> Int:
        return self.cols * self.layers * self.rows  

    # Get item with Layer , column , Row
    @always_inline
    fn __getitem__(self, z: Int, y: Int, x: Int) -> SIMD[T, 1]:
        return self.load[1](z, y, x)

    # Get item with  column , Row
    @always_inline
    fn __getitem__(self, y: Int, x: Int) -> SIMD[T, 1]:
        return self.load[1](y, x)

    # Get item with  Row
    @always_inline
    fn __getitem__(self, x: Int) -> SIMD[T, 1]:
        return self.load[1](0, x)

    # Set item with Layer , column , Row
    @always_inline
    fn __setitem__(self, z: Int, y: Int, x: Int, val: SIMD[T, 1]):
        return self.store[1](z, y, x, val)

    # Set item with column , Row
    @always_inline
    fn __setitem__(self, y: Int, x: Int, val: SIMD[T, 1]):
        return self.store[1](y, x, val)

    # Set item with  Row
    @always_inline
    fn __setitem__(self, x: Int, val: SIMD[T, 1]):
        return self.store[1](0, x, val)

    @always_inline
    fn load[nelts: Int](self, z: Int, y: Int, x: Int) -> SIMD[T, nelts]:
        return self.data.simd_load[nelts](z * self.layers + y * self.cols + x)

    @always_inline
    fn load[nelts: Int](self, x: Int) -> SIMD[T, nelts]:
        return self.data.simd_load[nelts](x)

    @always_inline
    fn load[nelts: Int](self, y: Int, x: Int) -> SIMD[T, nelts]:
        return self.data.simd_load[nelts](y * self.cols + x)

    @always_inline
    fn store[nelts: Int](self, z: Int, y: Int, x: Int, val: SIMD[T, nelts]):
        self.data.simd_store[nelts](z * self.layers + y * self.cols + x, val)

    @always_inline
    fn store[nelts: Int](self, x: Int, val: SIMD[T, nelts]):
        self.data.simd_store[nelts](x, val)

    @always_inline
    fn store[nelts: Int](self, y: Int, x: Int, val: SIMD[T, nelts]):
        self.data.simd_store[nelts](y * self.cols + x, val)

    @always_inline
    fn shape(self: Self) -> Tuple[Int, Int, Int]:
        var shape_: Tuple[Int, Int, Int] = (self.layers, self.cols, self.cols)
        return shape_
